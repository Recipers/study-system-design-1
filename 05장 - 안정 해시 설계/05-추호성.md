# 5. 안정 해시 설계

안정 해시는 키를 노드 클러스터에 균일하게 분산시키는 기술이다. 안정 해시 설계는 다중화 환경에서 장애로 인한 요청 재분배 문제를 효과적으로 해결한다. 일반적인 요청 재분배 문제가 어떤 문제를 가지며, 이를 어떻게 해결할 수 있을지 알아보자.

기본적으로 웹 계층 내의 서버는 무상태성을 가지므로 요청 재분배 문제를 고려하지 않아도 된다. 다중 캐시 서버 혹은 앞서 배운 처리율 제한 장치의 다중화에 사용할 수 있지 않을까?

<br>

## 1. 해시 키 재배치 문제

하단 예시에서 언급된 해시 함수는 엄밀히 말하면 서버 인덱스다. 왜냐하면 해시 함수에 의해 생성된 해시에 대해 서버와 매핑시키는 역할을 하기 때문이다. 그러나 해당 예제에서는 해시 함수라고 정의했다.

해시 함수가 `해시값 % 서버의 수`로 구성되어 있으며, 구체적으로 4대의 캐시 서버가 존재한다고 가정해보자. 한 대의 서버가 장애를 일으킬 경우 `해시값 % 4` 에서 `해시값 % 3`으로 해시 함수가 변경되며, 기존 모든 해시 결과를 재정의해야 한다. 그 결과, 기존 모든 요청이 다른 캐시 서버에 접속하게 되며, 다량의 캐시 미스가 발생한다.

→ 안정 해시가 이 문제를 효과적으로 해결할 수 있다.

<br>

## 2. 안정 해시

안정 해시는 서버의 변화에 따라 일부 해시만 재배치하는 해시 기술이다. 평균적으로 `키의 개수/서버의 수` 개수가 재배치 된다. 안정 해시는 해시 링을 이용하여 문제를 해결한다. 

### 해시 관련 용어 정리

해시 공간 : 해시값의 범위를 의미한다. SHA-1의 경우 0부터 2의160승-1 의 해시 공간을 가진다.

해시 링 : 해시 공간의 시작과 끝을 이어준 형태를 의미한다.

해시 서버 : 해시 링 위의 특정 위치에 대응시킨 서버를 의미한다.

해시 키 : 해시 링 위의 특정 위치에 대응시킨 키값을 의미한다. 위치한 키값은 특정 해시 서버에 대응되어야 한다.

<br>

## 3. 안정 해시 작동 원리

![시스템 디자인-6 jpg](https://github.com/user-attachments/assets/376553b3-6ee8-4b1c-ae15-60f274a44738)

해시 링 위에 존재하는 해시 서버의 해시 키 수용 범위는 `현재 해시 서버와 반시계 이전 해시 서버 사이`라고 생각하면 된다. S는 서버를 의미한다.

### 서버 조회

해시 키는 해시 링에서 시계 방향으로 이동했을 때, 처음으로 만나는 해시 서버와 대응된다. 하단 그림은 해시 서버와 해시 키의 대응 원리를 보여준다. k가 해시 키, s가 해시 서버다.

![image](https://github.com/user-attachments/assets/89651e4a-3561-4645-b1f1-b8fe6dbfbb28)

### 서버 추가

해시 링 위의 특정 위치에 서버를 추가할 수 있다. 이럴 경우, 특정 범위의 해시 키만 재배치하면 된다. 예를 들어, 서버3과 서버4 사이에 서버A를 추가할 경우(서버3 → 서버A → 서버4는 시계 방향으로 구성), 서버3과 서버A 사이의 해시 키만 서버A와 매핑시키면 된다. 

다음 그림은 상단 예시와는 별개며 서버4(s4)가 생성될 때, 해시 키 값 대응의 변화를 나타낸다.

![image](https://github.com/user-attachments/assets/140e0143-e282-4503-a558-cec0616e955c)

### 서버 제거

하나의 서버가 제거되면, 해당 서버에 매핑된 해시 키를 모두 다음 서버에 매핑하면 된다.  다음 그림은 서버 제거에 대해 나타낸다.

![image](https://github.com/user-attachments/assets/30239453-7f1f-44d8-bf34-50f1b7de7f4d)

### 서버 변경에 따른 데이터 재배치

서버가 추가, 제거되면 해당 서버의 반시계 방향에 존재하는 데이터의 매핑 대상을 변경해야 한다.

<br>

## 4. 안정 해시의 한계와 해결 방법

안정 해시의 기본 구현법에는 두 가지 문제가 존재하며, 가상 노드 도입을 통해 이를 해결할 수 있다.

### 기본 구현법의 두 가지 문제

- 서버를 추가, 제거하는 경우, 서버의 수용 범위 분포의 불균형이 나타날 수 있다.

- 수용 범위가 균등하다고 해도, 해시 키의 분포에 따라 서버가 수용하는 키의 분포가 불균형해질 수 있다는 점이다.

### 해결법: 가상 노드

가상 노드는 실제 노드 혹은 서버를 가리키는 노드를 의미하며, 여러 개의 가상 노드가 하나의 실제 서버를 가리킬 수 있다. 

각 해시 서버에 대해 많은 수의 가상 노드를 만들어 해시 링에 고르게 섞어 분포시킨다. 이렇게 되면, 하나의 해시 링에 서버의 수용 범위가 잘게 나뉘어 섞여지게 된다. 따라서, 언급된 두 가지 문제가 어느정도 해소된다.

가상 노드의 개수가 늘어날 경우 불균형 문제를 더욱 해소할 수 있지만, 가상 노드 데이터를 저장할 공간이 더 요구된다. 즉, 균형의 정도와 저장 공간의 트레이드오프가 발생한다.

![시스템 디자인-8 jpg](https://github.com/user-attachments/assets/28da2b7a-d6e0-4ddc-b302-9be061a9c5ff)

<br>

## 5. 의문점

*가상 노드를 키의 분포에 따라 알맞은 위치에 동적으로 추가할 수 있다면, 적은 가상 노드로도 효과적인 안정 해시를 만들 수 있지 않을까 ?*

*가상 노드를 카운터와 함께 B+Tree로 관리하면 더욱 효과적이지 않을까? 가상 노드 저장 자료구조에 대한 정보가 나타나있지 않다.(서칭도 안된다)*

*다음은 B+Tree를 이용한 가상 노드 관리 방법에 대한 개인적인 생각이다(추호성 뇌피셜) 가상 노드가 지정한 해시 범위의 시작점을 key 값으로, 대상 서버와 가상 노드가 수용하고 있는 해시 키의 수(counter)를 value 값으로 가지는 B+Tree를 구성한다.*

*특정 해시 키가 입력될 경우, B+Tree를 타고 내려가 알맞은 리프 노드에 counter를 증가시킨다. counter가 특정 크기를 넘어갈 경우, 리프 노드를 스플릿한다.*

*해당 B+Tree는 해시 키 분포에 따른 적절한 가상 노드의 위치 정보를 나타내준다.*

![시스템 디자인-7](https://github.com/user-attachments/assets/8d8b66ec-03a3-470c-9e5a-f77a60015dd6)


