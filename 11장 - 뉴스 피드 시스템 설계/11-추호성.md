# 11. 뉴스 피드 시스템 설계

## 1. 문제 이해 및 설계 범위 확정

면접관에게 물어보자

- 앱, 웹 지원

- 사용자는 뉴스 피드 페이지에 새로운 스토리를 올리며, 친구의 스토리도 볼 수 있어야 함
- 피드는 단순 시간 역순
- 한 명의 사용자는 최대 5천명의 친구를 가짐
- 매일 천만 명이 방문
- 피드엔 이미지, 비디오도 올릴 수 있음

<br>

## 2. 개략적 설계안 제시 및 동의 구하기

피드 발행과 뉴스 피드 생성 기능을 구현해보자.

- 피드 발행 : 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 DB에 기록한다. 새 포스팅은 친구의 뉴스 피드에도 전송한다.

- 뉴스 피드 생성 : 뉴스 피드는 모든 친구의 포스팅을 최신순으로 출력한다.

<br>

### 뉴스 피드 API

두 가지 API를 살펴보자

<br>

### 피드 발행 API

새 피드를 포스팅 하는 기능으로, HTTP POST 형태로 요청한다. URL은 `POST/v1/me/feed` 형태이며, 인자로 바디와 authorization 헤더를 가진다.

<br>

### 피드 읽기 API

뉴스 피드를 가져오는 API다. URL은 GET `/v1/me/feed` 형태이며, 인자로 authorization 헤더를 가진다.

<br>

### 피드 발행

피드 발생 시스템의 개략적 아키텍쳐는 다음과 같다. 각 역할은 다음과 같다.

- 사용자 : 웹, 앱에서 새 피드를 올리는 주체

- 로드밸런서 : 사용자 트래픽을 골고루 여러 웹 서버에 골고루 분산
- 웹 서버 : HTTP 요청을 내부 서비스로 중계
- 포스팅 저장 서비스 : 새 포스팅을 DB와 캐시에 저장
- 포스팅 전송 서비스 : 새 포스팅을 친구의 뉴스 피드에 발행. 뉴스 피드 데이터는 캐시에 보관하여 빠르게 읽을 수 있다.

![image.png](attachment:4b6d0255-a803-4991-b425-85ddf594c2df:image.png)

<br>

### 뉴스 피드 생성

- 사용자 : 뉴스 피드를 읽는 주체. GET 메서드를 통해 읽는다.

- 로드 밸런서 : 조회 요청을 웹 서버에 골고루 분배한다
- 웹 서버 : 트래픽을 뉴진스 피드 서비스로 보낸다.
- 뉴스 피드 서비스 : 캐시에서 뉴스 피드를 가져오는 서비스
- 뉴스 피드 캐시 : 뉴스 피드를 랜더링할 때 필요한 피드 ID를 보관

![image.png](attachment:f229fa23-485a-4188-ae80-07778fd1a1d8:image.png)

<br>

## 3. 상세 설계

각 기능을 상세하게 설계해보자

<br>

### 피드 발행 흐름 상세 설계

다음은 피드 발행 흐름에 대한 상세 설계다. 웹 서버와 포스팅 전송 서비스에 중점을 맞췄다.

![image.png](attachment:a1c5614c-7d94-475a-a79e-59a47104a658:image.png)

웹 서버는 통신 뿐만 아니라 인증, 처리율 제한 등의 기능도 수행한다.

피드 전송 서비스는 팬아웃 기능을 하는데, 특정 사용자의 새 포스팅을 친구 관계인 모든 사용자에게 전달하는 과정이다. 팬아웃에는 두 모델이 있는데, 하나는 쓰기 시점에 팬아웃이며, 다른 하나는 읽기 시점에 팬아웃이다.

쓰기 시점에 팬아웃은 새로운 피드를 기록하는 시점에 뉴스 피드를 갱신한다. 즉, 포스팅이 완료되면 해당 사용자의 캐시에 해당 피드를 기록하는 것이다. 다음과 같은 장단점이 있다. → 해당 모델이 PUB SUB 모델 ? 메시지 큐는 각자 가지고 있는건가 ? 공통으로 운영한다면, 메세지 큐엔 어떤 데이터가 저장되어 있나 ?

→ 피드를 쓰는 시점에 사용자의 모든 친구의 피드 조회 데이터를 갱신하는 방식인가? 그러면 각 사용자의 피드 조회 데이터는 어떻게 구성하지 ? → 사용자마다 별도의 캐시를 제공하나 ? → 하단에 기술

장점

- 뉴스 피드의 실시간 갱신

- 뉴스 피드를 읽는데 드는 시간이 짧아짐

단점

- 친구가 많은 사용자의 경우 뉴스 피드 갱신에 높은 시간 비용이 소요(핫키 문제)

- 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신하므로 자원 낭비 야기

읽기 시점에 팬아웃은 피드를 읽는 시점에 뉴스 피드를 갱신한다. 따라서 이는, 요청 기반 모델이다.

장점

- 비활성화 사용를 다루는데 유리

- 사용자의 피드 발행도 없으므로 핫키 문제 해결.(단순히 구독자가 읽는 방식)

단점

- 뉴스 피드를 읽는 데 많은 시간이 소요

[개인적으로 이해한 쓰기 시점 팬아웃 모델]

포스트를 쓴 시점에 연관된 모든 사용자의 피드를 갱신하는 방식으로 이해했다. 해당 방식은 사용자가 피드를 읽는 시점에 포스트를 빠르게 읽을 수 있다는 장점이 있지만, 인플루언서가 포스팅을 했을 때, 작업 서버가 많이 작동해야 한다는 단점(핫 키 문제), 이용량이 적은 사용자의 피드도 갱신해야 한다는 단점이 있다.

읽기 시점 팬아웃 모델과 가장 큰 차이점은 피드 저장소의 갱신 여부라고 생각한다. 쓰기 시점 팬아웃 모델은 포스팅이 생성될 때 마다, 피드를 갱신한다.

작동 과정과 기술은 다음과 같다.

1. 사용자가 포스트를 생성 및 포스트 DB에 저장

2. 그래프 DB를 이용해서 사용자와 연관된 사용자 전체 조회
3. 조회한 사용자 필터링 및 사용자의 피드 ID 추출
4. 피드 ID와 포스트 ID를 메세지 큐에 입력
5. 여러 작업 서버는 메세지 큐에서 데이터를 소비해 피드 캐시 갱신 및 DB에 저장

[개인적으로 이해한 읽기 시점 팬아웃 모델]

사용자가 피드를 읽는 시점에서 피드를 갱신하는 방식으로 이해했다. 해당 방식은 사용자의 요청에 맞춰 피드를 읽기 때문에, 이용량이 적은 사용자에게 적은 자원을 사용해도 된다는 장점이 있지만, 요청 시 데이터를 조회하기 때문에 느리다는 단점이 있다.

사용자가 피드를 읽을 경우, 마지막으로 본 피드의 시간을 추출한 뒤, 그 이후 포스트를 DB에서 가져오는 방식인건가 ?

쓰기 시점 팬아웃 모델의 경우 사용자가 피드를 읽을 때, 절대 대다수 피드가 캐싱되어있서 속도가 빠르다. 그러나 읽기 시점 모델은 새로 보는 피드에 대해서 항상 DB에서 조회해야 한다.

작동 과정은 다음과 같다.

1. 사용자가 피드를 읽음

2. 그래프 DB를 이용해서 사용자와 연괸된 사용자 전체 조회
3. 조회한 사용자 필터링 및 사용자가 작성한 포스팅(마지막으로 피드를 읽은 시점 이후가 조건) 캐싱 및 조회

두 방법을 결합하여 속도를 조절해보자. 대부분의 사용자에겐 푸시 모델을 적용하되, 팔로워가 많은 인기 사용자에겐 풀 모델을 이용하여 시스템 과부화를 방지하자. 아울러 안정 해시를 통해 요청과 데이터를 고르게 분산하여 핫키 문제를 해소하자.

구체적인 방식은 ? 일반 사용자가 포스팅할 경우, 그와 연관된 사용자의 피드를 갱신한다. 사용자가 피드를 조회할 경우, 먼저 캐시를 확인하여 일반 사용자의 포스트를 가져온 뒤, 포스트DB를 뒤져 인플루언서 포스트를 가져온다.(인플루언서 포스트 캐시를 만들어 읽는 방식도 괜찮을 듯) 

이는 (포스트)생성자와, 소비자의 “쓰기-읽기 작업 책임 전가”라고 생각한다. 쓰기 팬아웃의 경우 생성자가 쓰기 부담을 갖는 대신, 소비자의 읽기 부담이 줄어든다. 반면, 읽기 팬아웃의 경우 소비자의 쓰기 부담이 줄어든 대신, 소비자의 읽기 부담이 늘어난다. 

인플루언서의 경우 많은 소비자를 보유하기 때문에, 읽기 팬아웃을 통한 읽기 부담을 소비자에게 전가하는 것이 옳다.

팬아웃 서비스는 다음과 같이 동작한다.

1. 그래프 DB에서 친구들의 정보를 가져온다.

2. 사용자 정보 캐시에서 친구 정보를 가져온다. 이 과정에서 ‘스토리 숨기기’와 같은 기능으로 차단한 유저를 거를 수 있다.
3. 친구 목록과 새 스토리의 피드 ID를 메세지 큐에 넣는다.
4. 메세지 큐에서 꺼낸 데이터는 뉴스 피드 캐시에 저장한다. 이 때, 캐시엔 <포스팅 ID, 사용자 ID>의 순서쌍을 보관한다. 사용자는 캐시 데이터를 기반으로 최신 피드 목록이 구성된다.(캐시엔 어떤 사용자가 어떤 포스팅 ID를 읽어야 하는지 저장되어 있다)
5. 수천개의 피드를 내려가면서 읽는 사용자는 거의 없기 때문에, 캐시 미스가 거의 나지 않는다.

![image.png](attachment:35cdae0b-e564-4cdf-b817-c9a8e26eeeac:image.png)

<br>

### 피드 읽기 흐름 상세 설계

뉴스 피드 읽기 과정은 다음과 같다.

1. 사용자가 조회 요청을 보낸다

2. 로드밸런서가 요청을 적절한 웹서버로 전송한다.
3. 웹 서버에서 인증과 처리율 제한 과정을 거친 뒤, 뉴스 피드 서비스에 요청을 전송한다.
4. 먼저 뉴스 피드 캐시를 확인한다. 뉴스 피드 캐시는 <포스팅 ID, 사용자 ID>로 구성되어 있다.
5. 캐시에 데이터가 존재하는 경우, 사용자 정보 캐시에서 포스팅 제작자를, 포스팅 캐시에서 포스팅 정보를 가져온 뒤, 사용자에게 반환한다.

![image.png](attachment:5f8bbf80-380a-4ebe-9062-4cd4ee5bf8cc:image.png)

뉴스 피드 캐시 구조가 어떻게 되지? 캐시는 시간 기준 최신으로 정렬됐으며, 조회 시 상위 K개의 데이터만 추출하는건가 ? → 읽기 팬아웃, 쓰기 팬아웃에 따라 다르다.

<br>

### 캐시 구조

캐시는 뉴스 피드 시스템의 핵심 컴포넌트다. 뉴스 피드 시스템 아키텍쳐는 다음과 같이 다섯 계층으로 나눠진다.

- 뉴스 피드 : 뉴스 피드의 ID를 보관

- 컨텐츠 : 포스팅 데이터를 보관. 인기 컨텐츠는 따로 보관
- 소셜 그래프 : 사용자 간 관계 정보를 보관
- 행동 : 포스팅에 대한 사용자의 행위에 관한 정보를 보관(좋아요, 답글 등등)
- 횟수 : 좋아요, 응답, 팔로워, 팔로잉 수 등의 정보 보관

![image.png](attachment:e245a75e-6ee8-46c1-b70a-6227fbbb2fbf:image.png)

<br>

## 4. 마무리

회사마다 독특한 제약이나 요구 조건이 있기 때문에, 다양한 구현 방법과 그에 따른 트레이드 오프를 이해하고 설명할 수 있어야 한다.

다음과 같은 주제를 추가적으로 의논해보자

- 수직 규모 확장 vs 수평 규모 확장

- SQL vs NoSQL
- 마스터 슬레이브 다중화
- 복제본에 대한 읽기 연산
- 일관성 모델
- 데이터베이스 샤딩
- 웹 계층의 무상태성 운영
- 가능한 많은 데이터를 캐싱하는 방법
- 여러 데이터 센터를 지원할 방법
- 메세지 큐를 이용한 결합도 낮추기
- 핵심 메트릭에 대한 모니터링