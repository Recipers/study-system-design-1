# 15. 구글 드라이브 설계

구글 드라이브는 파일 저장 및 동기화 서비스다. 웹, 앱 등 다양한 단말기에서 접속 가능하며, 동료들과 파일을 쉽게 공유할 수 있어야 한다.

## 1. 문제 이해 및 설계 범위 확정

면접관과 대화를 통해 설계 범위를 좁혀보자

- 기능은 파일 업로드, 다운로드, 파일 동기화, 알림이 존재한다.

- 웹, 앱 단말기를 지원한다.
- 파일은 암호화된다.
- 파일 크기는 10기가로 제한된다.
- DAU는 1000만명이다.

이 과정에서 다음 기능의 설계에 집중할 것이다.

- 파일 추가

- 파일 다운로드
- 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편접, 삭제되거나 공유됐을 때 알림 표시

기능적 요구 사항 이외에, 비 기능적 요구사항도 중요하다.

- 안정성 : 저장한 데이터가 안전해야 한다.

- 빠른 동기화 속도 : 파일 동기화 시간이 짧아야 한다.
- 네트워크 대역폭 : 네트워크 대역폭을 많이 소모하면 안된다.
- 규모 확장성 : 많은 양의 트래픽을 처리해야 한다.
- 높은 가용성 : 일부 서버에 장애가 있어도 지속적으로 작동해야 한다.

개략적 추정치를 고민해보자.

## 2. 개략적 설계안 제시 및 동의 구하기

한 대의 서버를 시작으로 점진적으로 개선해보자. 한 대의 서버로 진행할 경우, 다음과 같이 아키텍처를 구축할 수 있다.

- 파일을 올리고 내려받는 과정을 처리할 웹 서버

- 사용자 데이터, 로그인 정보, 파일 정보 등의 메타 데이터를 보관할 데이터베이스
- 파일을 저장할 저장소 시스템. 파일 경로를 통해 유일 식별자를 얻을 수 있다.

![image.png](attachment:d240d231-17e1-4ec7-8f7e-d8cef60ce4d1:image.png)

### API

파일 업로드 API, 다운로드 API, 파일 갱신 히스토리 제공 API가 필요하다. 추가적으로 보안을 위해 SSL 프로토콜을 지원해야 한다.

### 파일 업로드 API

단순 업로드와 이어 올리기가 존재한다. 단순 업로드는 파일 크기가 작을 때 사용되는 반면, 이어 올리기는 파일 사이즈가 큰 경우 사용된다. 파일 업로드 API는 uploadType, data 인자를 가진다. uploadType=resumable일 경우, 이어 올리가 작동한다.

이어 올리기는 파일 사이즈가 크고 업로드가 중단될 가능성이 높을 때 사용된다. 이어 올리기는 세 단계 절차로 구성된다.

- 이어 올리기 URL을 받기 위한 최초 요청 전송

- 데이터를 업로드하고 업로드 상태 모니터링
- 업로드에 장애가 발생하면 장애 발생시점부터 업로드 재시작

### 다운로드 API

path=파일 경로 를 인자로 받는다.

### 파일 갱신 히스토리 제공 API

인자로 path, limit값을 가지며, 각각 갱신 히스토리를 가져올 파일의 경로와 히스토리 길이의 최대치를 나타낸다.

### 한 대 서버의 제약 극복

S3는 규모 확장성, 가용성, 보인, 성능을 제공하며, 특히 여러 지역에 걸쳐서 다중화할 수 있다. S3 외에 추가적으로 개선할 부분을 찾아보자.

- 로드밸런서 : 네트워크 트레픽 분산을 위해 사용한다. 로드밸런서는 트래픽 분산 뿐만 아니라, 장애 서버를 우회해주는 역할을 한다.

- 웹 서버 : 로드밸런서를 추가하면 더 많은 웹서버를 추가할 수 있다. 이는 트래픽 폭증에 내성을 가질 수 있다.
- 메타데이터 DB : DB를 파일 저장소와 분리하여 SPOF 문제를 회피한다. 아울러 다중화 및 샤딩 정책을 적용하여 가용성과 규모 확장성에 대응한다. (한번에 오류가 발생하는걸 막는다는건가? → 책임 분산?)
- 파일 저장소 : S3를 파일 저장소로 사용하고 가용성과 데이터 무손실을 보장하기 위해 두 개 이상의 지역에 데이터를 다중화한다.

로드밸런서는 장애 서버를 어떻게 진단하는가? → 주기적으로 특정 형식의 요청을 보내 헬스 체크를 진행한다

### 동기화 충돌

두 명 이상의 사용자가 동시에 같은 파일이나 폴더를 업로드하는 경우, 동기화 충돌 문제가 발생한다. 여러 전략이 있지만, 먼저 처리되는 변경을 성공처리하고, 나중에 처리되는 변경을 충돌 발생으로 표기하는 것이다.

충돌로 발생한 오류는 어떻게 해결하나? 오류 발생 시점에 같은 파일의 두 가지 버전이 존재한다. 이를 하나로 합칠지, 둘 중 하나를 다른 파일로 대체할지 결정해야 한다.

그 외에 어떤 충돌 정책이 있을까? → 책에 기재된 논문은 차등 동기화 알고리즘을 설명하고 있음

### 개략적 설계안

다음은 개략적 설계안이다. 각 컴포넌트에 대해 상세하게 알아보자.

![image.png](attachment:c02c657f-39c2-430d-8dac-4dc4db2e0b21:image.png)

- 사용자 단말
    - 설명 생략

- 블록 저장소 서버
    - 파일 블록을 클라우드 저장소에 업로드하는 서버다.

    - 파일을 여러 개의 블록으로 나눠 저장하며, 각 블록에는 고유 해시값이 할당된다. 이 해시값은 메타데이터 DB에 저장된다.
    - 각 블록은 독립적인 객체로 취급되며 클라우드 저장소 시스템에 보관된다.
    - 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 한다. 드롭박스의 경우 하나의 블록 당 4MB 정도 된다.
- 클라우드 저장소
    - 파일은 블록 단위로 나눠져 클라우드 저장소에 보관된다.
- 아카이빙 저장소
    - 오랫동안 사용되지 않은 비활성 데이터를 저장하기 위한 컴퓨터 시스템이다.
- 로드밸런서
    - 요청을 모든 API 서버에 고르게 분산하는 역할을 한다.
- API 서버
    - 사용자 인증, 프로필 관리, 파일 메타데이터 갱신에 사용된다.
- 메타데이터 DB
    - 사용자, 파일, 블록, 버전 등의 메타데이터 정보를 관리한다. 실제 파일은 클라우드에 보관되며, 해당 DB에는 메타 데이터만 관리한다.
- 알림 서비스
    - 특정 이벤트가 발생했음을 클라이언트에 알리는데 쓰이는 발생/구독 프로토콜 기반 시스템이다. 파일이 추가, 편집, 삭제되었음을 알려 파일의 최신 상태를 확인하도록 하는데 쓰인다.
- 오프라인 사용자 백업 큐
    - 클라이언트가 접속 중이 아닐 때, 해당 큐에 정보를 쌓아둔 뒤, 접속 후 동기화한다.

    - 해당 백업 큐는 사용자 당 하나씩 만들어지나? 아니면 하나만 만들어지나? 작동 방식은 어떻게 되지? 그리고 어떤 기술을 쓰지?

## 3. 상세 설계

각 컴포넌트를 자세히 살펴보자

### 블록 저장소 서버

정기적으로 갱신되는 큰 파일들은 업데이트가 일어날 때 마다 전체 파일을 서버로 보내면 네트워크 대역폭을 많이 잡아먹게 된다. 이를 최적화 하는 방법은 두 가지 존재한다.

- 델타 동기화 : 파일 수정이 일어날 경우, 수정된 부분만 동기화

- 압축 : 블록 단위로 압축하여 크기를 축소한다. 다양한 압축 알고리즘이 존재한다.

블록 저장소 서버는 입력된 파일을 블록 단위로 나누고 압축하고 암호화하는 역할을 한다. 아울러 전체 파일이 아닌 변경된 블록만 클라우드 저장소에 전송한다.

![image.png](attachment:3de12f28-ce14-4336-baf0-173560e53dcd:image.png)

다음 그림은 수정된 블록만 전송하는 과정을 나타낸다. 

블록은 어떤 기준으로 나뉘어지는가? 변경된 부분에 대한 블록을 어떻게 타겟하여 감지하는가? 문서의 경우, 블록을 줄 단위로 나누는건가? 그렇다면 중간에 내용을 추가할 경우, 그 아래 내용이 밀려나며 블록의 내용이 변경될텐데, 이를 어떻게 해결하는가 ?

만약 일부분이 변경된 새 버전이 등장한다면, 해당 버전의 모든 블록의 메타데이터는 전부 저장되는가?

![image.png](attachment:83fd326b-ed85-4f69-b6bb-12c8b61695f7:image.png)

### 높은 일관성 요구사항

다음 시스템은 강한 일관성 모델을 기본으로 지원해야 한다. 즉, 같은 파일이 사용자나 단말마다 다르게 보이면 안된다. 이는 DB 뿐만 아니라, 캐시에도 적용되어야 한다.

메모리 캐시는 보통 최종 일관성 모델을 지원한다. 따라서 강한 일관성을 달성하려면 다음을 보장해야 한다.

- 캐시에 보관된 사본과 DB에 있는 원본이 일치

- DB에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화

관계형 DB는 ACID를 보장하므로 강한 일관성을 보장하기 쉽다. 그러나 NOSQL은 이를 보장하지 않기 때문에 동기화 로직 안에 프로그램해 넣어야 한다. 사용이 쉬운 RDB를 이용하여 높은 일관성을 챙기자.

### 메타데이터 데이터베이스

메타데이터 데이터베이스 안에는 사용자, 네임스페이스, 파일 정보, 파일 버전, 블록, 사용자 단말 정보가 테이블 형태로 들어있다.

여기서 네임스페이스 테이블은 사용자의 루트 디렉토리 정보가 보관되어 있다. 또한, 블록 테이블은 파일 블록에 대한 정보 및 순서를 보관하는데, 순서를 맞춰 파일을 복원할 수 있다.

### 업로드 절차

사용자가 파일을 업로드하면 메타 데이터 DB에 파일의 정보, 클라우드 저장소에 파일을 업로드하게 되며, 이는 병렬적으로 처리된다.

파일 메타 데이터 추가 작업은 다음과 같은 과정을 거친다.

1. 클라이언트가 새 파일의 메타 데이터를 추가하기 위한 요청 전송

2. 새 파일의 메타 데이터를 DB에 저장한 뒤, 업로드 상태를 대기중으로 변경
3. 새 파일이 추가되었음을 알림 서비스에 통지
4. 알림 서비스는 관련된 모든 클라이언트에게 파일이 업로드되고 있음을 알림

파일을 클라우드 저장소에 업로드

1. 클라이언트가 파일을 블록 저장소 서버에 업로드

2. 블록 저장소 서버는 파일을 블록 단위로 쪼갠 뒤, 압축하고 암호화한 다음에 클라우드 저장소에 전송
3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출. 이 콜백 호출은 API 서버로 전송됨
4. 메타 데이터 DB에 기록된 해당 파일의 상태를 완료로 변경
5. 알림 서비스에 파일 업로드가 끝났음을 통지
6. 알림 서비스는 관련된 클라이언트에게 파일 업로드가 끝났음을 알림

결국 파일 전체를 클라우드로 올리는 과정 전후로 메타 데이터를 추가 및 갱신하는 과정을 거친다.

### 다운로드 절차

파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다. 다른 클라이언트가 파일을 편집하거나 추가한 사실을 알아야 하는데, 이는 두 가지 방법을 이용한다.

- 클라이언트 A가 접속 중 파일이 변경되면, 알림 서비스가 A에게 변경이 발생했음을 알린다.

- 클라이언트 A가 접속 중이 아니면, 데이터를 캐시에 보관하고 A가 접속 중으로 바뀌면 그 때, 새 버전을 가져온다. 무슨 데이터를 캐시에 보관하는거지 ?

과정은 다음과 같다.

1. 알림 서비스가 클라이언트에네 누군가 파일을 변경했음을 알림

2. 알림을 확인한 클라이언트는 새로운 메타데이터를 요청
3. API 서버는 메타데이터 DB에게 새 메타데이터 요청
4. API 서버에게 새 메타데이터가 반환
5. 클라이언트에게 새 메타데이터가 반환
6. 클라이언트는 새 메타데이터를 받은 즉시 블록 다운로드 요청을 블록 서버에 전송
7. 블록 서버는 클라우드 저장소에서 블록 다운로드
8. 클라우드 저장소는 블록 서버에 블록 반환
9. 블록 저장소 서버는 클라이언트가 요청한 블록 반환. 클라이언트는 받은 블록을 사용하여 파일 재구성

### 알림 서비스

파일의 일관성 유지를 위해, 알림 서비스는 파일 쓰기 기능이 작동하는 순간, 다른 클라이언트에게 그 사실을 알려서 충돌 가능성을 줄여야 한다. 결과적으로 알림 서비스는 이벤트 데이터를 클라이언트로 보내는 서비스다. 다음 두 가지 통신 방식이 있다.

- 롱 폴링 : 반환이 올 때 까지 요청을 열어두는 방식 ?

- 웹소켓 : 클라이언트와 서버 사이 지속적 양방향 통신 채널

본 설계의 경우 롱 폴링 방식을 이용하며, 이유는 다음과 같다.

- 변경된 데이터에 대해서 서버가 클라이언트에게 일방적으로 전달하는 구조기 때문에, 양방향으로 통신할 필요가 없다.

- 해당 서비스의 경우, 알람이 상대적으로 많이 발생하지 않으며, 알람을 보내는 경우에도 단시간에 많이 보낼 필요가 없다. 롱 폴링 방식을 쓰면 각 클라이언트는 알람 서버와 롱 폴링 방식으로 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 해당 연결을 종료한다.
- 이 때, 클라이언트는 반드시 메타데이터 서버와 연결해 파일의 최신 내역을 다운로드 해야 한다. 해당 다운로드 작업이 끝났거나 연결 타임아웃 시간에 도달한 경우에는 즉시 새 요청을 보내어 롱 폴링 연결을 복원하고 유지해야 한다.

### 저장소 공간 절약

파일 갱신 이력을 보존 및 안정성을 보장하기 위해서는 파일의 여러 버전을 여러 데이터센터에 보관해야 한다. 그러나 모든 버전을 자주 백업할 경우, 저장 용량이 빨리 소진될 수 있다. 해당 문제를 피하기 위해 세 가지 방법을 이용한다.

- 중복 제거
    - 중복된 파일 블록을 계정 차원에서 제거한다. 두 블록이 같은지는 해시 값을 비교하여 판단한다.

- 지능적 백업 전략
    - 보관하는 백업 파일의 개수 한도를 지정한다.

    - 자주 바뀌는 파일에 대해서는 중요한 버전만 보관한다. 공유 문서의 경우가 이에 해당한다.
- 아카이빙 저장소 유배
    - 자주 쓰지 않는 데이터는 아카이빙 저장소에 유배시킨다. 아마존 S3 글래시어와 같은 저장소는 S3보다 저렴하다.

### 장애 처리

다양한 형태의 장애가 생길 수 있다.

- 로드밸런서 장애
    - 로드밸런서도 다중화할 수 있으며, 이들은 heartBeat를 통해 상태를 모니터링한다. 일정 시간동안 박동 신호에 응답하지 않는다면 장애 취급한다.

- 블록 저장소 서버 장애
    - 다중화를 통해 문제를 해결할 수 있다. 특정 서버에 장앵가 발생한 경우, 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어받는다.
- 클라우드 저장소 장애
    - S3 버킷은 여러 지역에 다중화할 수 있으므로, 한 지역에서 장애가 발생한다면 다른 지역에서 파일을 가져올 수 있다.
- API 서버 장애
    - API 서버들은 무상태성을 가지기 때문에, 장애가 발생해도 로드밸런서가 적절하게 트래픽을 분배하여 대응한다.
- 메타데이터 캐시 장애
    - 메타데이터 캐시 서버도 장애가 발생할 수 있어, 다중화가 필요하다.
- 메타데이터 데이터베이스 장애
    - 메타데이터 DB는 주-부 관계를 가진다.
    - 주 데이터베이스 서버 장애가 발생한 경우, 부 데이터베이스 중 하나를 주 데이터베이스로 변경하고, 부 데이터베이스를 하나 추가한다.

    - 부 데이터베이스 서버 장애가 발생한 경우, 트래픽을 적절하게 분배하여 문제를 해결한다.
- 알림 서비스 장애
    - 접속 중인 모든 사용자는 알림 서버와 롱 폴링 연결을 하나씩 유지한다.

    - 만약 한 대의 알람 서버에 장애가 발생할 경우, 이와 연결된 모든 사용자와 다시 롱 폴링 방식으로 연결해야 한다. 많은 연결을 유지하는 것은 가능하지만, 동시에 많은 연결을 시작하는 것은 불가능하며, 복구에 오랜 시간이 걸릴 수 있다.
- 오프라인 사용자 백업 큐 장애
    - 큐 또한 다중화 해야 한다. 큐에 장애가 발생할 경우, 백업 큐로 구독 관계를 재설정해야 한다.

## 4. 마무리

높은 수준의 일관성, 낮은 네트워크 지연, 빠른 동기화가 요구된다는 점이 흥미로웠다. 드라이브 서비스는 파일의 메타데이터 관리, 파일 동기화를 처리하는 부분으로 구분되며, 알람 서비스는 이 두 과정에 겹쳐있다.

회사마다 요구하는 제약 조건이 달라질 수 있으니, 그에 맞게 설계를 진행해야 한다. 그 과정에서 내린 결정들과 선택한 기술들 이면에 어떤 생각이 있었는지 면접관에서 설명핼 수 있도록 기억해두자.

그 외에도 설계안에 어떤 다른 선택지가 존재하는지 고민해보자.

## 5. 주요 질문

- 구체적인 알림 시스템 아키텍처와 작동 흐름(특히 백업 큐 설정 정책에 관해서)

- 충돌 해결 정책
- 캐시 정책과 각 정책의 장단점
- 블록 단위 및 블록 설정 기준
    - 잘 안나옴…
- 데이터 변경 감지 방식
- 쓰기, 읽기, 수정의 정확한 작동 흐름
- 구체적인 메타데이터 DB 구조

---

### **롱 폴링의 동작 방식**

1. 클라이언트가 서버에 요청을 보냄
    - 일반적인 HTTP 요청과 동일하지만, 서버는 즉시 응답하지 않음.

2. 서버가 데이터가 준비될 때까지 대기
    - 서버는 특정 이벤트가 발생할 때까지 응답을 지연시킴.
3. 데이터가 준비되면 서버가 응답 반환
    - 서버에서 새로운 데이터가 생성되면 클라이언트에게 응답을 보냄.
4. 클라이언트가 새로운 요청을 보냄
    - 클라이언트는 응답을 받은 후 다시 서버에 새로운 요청을 보내는 과정을 반복.

롱 폴링은 서버가 클라이언트의 연결을 유지해야 하기 때문에, 부하가 증가할 수 있다. 연결 비용만 있을거 같은데 왜 부하가 증가하는거지? → 서버 측에서 클라이언트와의 연결을 유지하기 위한 대상이 있어야 하기 때문이다.

서버가 먹이를 줄 때 까지, 클라이언트는 계속 입을 벌리고 있다.

### 캐시 전략

[캐시 전략](https://www.notion.so/18328dbdd85b808db624e098a48faa01?pvs=21) 

### 충돌 정책

같은 위치에 같은 파일을 동시에 입력할 경우, 충돌이 발생한다. 이는 다양한 방식으로 해결할 수 있으며, 드라이브의 사용 형태에 따라 알맞게 선택하면 좋을거 같다.(실시간 문서 협업 형태, 개인 저장소, 공유 저장소 등)

충돌 해결 정책의 경우 최종 작성자 우선, 버전 관리, 변경 사항 병합, 충돌 사본 저장 등이 있으며, 각각 특징이 다르다.

해당 드라이브 시스템은 공유 저장소 역할을 하며, 안전성이 중요하기 때문에 버전 관리 + 충돌 사본 저장 방식을 사용하는게 좋지 않을까? 왜냐하면 동시 입력을 통해 특정 파일이 사라지면 문제가 발생할 수 있기 때문이다.